
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">PR_service/internal/api/handlers.go (0.0%)</option>
				
				<option value="file1">PR_service/internal/api/middleware.go (0.0%)</option>
				
				<option value="file2">PR_service/internal/api/utils.go (26.7%)</option>
				
				<option value="file3">PR_service/internal/storage/storage.go (5.7%)</option>
				
				<option value="file4">PR_service/internal/storage/test_table.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "log"
        "net/http"

        "PR_service/internal/models"
        "PR_service/internal/storage"
)

type Handler struct {
        store *storage.StorageData
}

func NewHandler(s *storage.StorageData) *Handler <span class="cov0" title="0">{
        return &amp;Handler{store: s}
}</span>

func (h *Handler) AddTeam(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var t models.Team
        if !h.bindJSON(w, r, &amp;t) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if errMsg := validateRequiredFields(map[string]string{
                "team_name": t.TeamName,
        }); errMsg != "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, errMsg)
                return
        }</span>

        <span class="cov0" title="0">if err := h.store.UpsertTeam(r.Context(), t); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeSuccess(w, http.StatusCreated, "team created")</span>
}

func (h *Handler) GetTeam(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        teamName := r.URL.Query().Get("team_name")
        if teamName == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "team_name query parameter is required")
                return
        }</span>

        <span class="cov0" title="0">team, err := h.store.GetTeam(r.Context(), teamName)
        if err != nil </span><span class="cov0" title="0">{
                h.handleStorageError(w, err, "GetTeam")
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, map[string]interface{}{"team": team})</span>
}

func (h *Handler) SetIsActive(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req models.SetActiveRequest
        if !h.bindJSON(w, r, &amp;req) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if errMsg := validateRequiredFields(map[string]string{
                "user_id": req.UserID,
        }); errMsg != "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, errMsg)
                return
        }</span>

        <span class="cov0" title="0">if err := h.store.SetUserActive(r.Context(), req.UserID, req.Active); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">writeSuccess(w, http.StatusOK, "user updated")</span>
}

func (h *Handler) CreatePR(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req models.CreatePRRequest
        if !h.bindJSON(w, r, &amp;req) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if errMsg := validateRequiredFields(map[string]string{
                "pull_request_id":   req.PullRequestID,
                "pull_request_name": req.PullRequestName,
                "author_id":         req.AuthorID,
        }); errMsg != "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, errMsg)
                return
        }</span>

        <span class="cov0" title="0">createdPR, err := h.store.CreatePR(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                h.handleCreatePRError(w, err)
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusCreated, map[string]interface{}{"pr": createdPR})</span>
}

func (h *Handler) MergePR(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                PullRequestID string `json:"pull_request_id"`
        }

        if !h.bindJSON(w, r, &amp;req) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if req.PullRequestID == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "pull_request_id is required")
                return
        }</span>

        <span class="cov0" title="0">mergedPR, err := h.store.MergePR(r.Context(), req.PullRequestID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleStorageError(w, err, "MergePR")
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, map[string]interface{}{"pr": mergedPR})</span>
}

func (h *Handler) ReassignReviewer(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                PullRequestID string `json:"pull_request_id"`
                OldUserID     string `json:"old_user_id"`
        }

        if !h.bindJSON(w, r, &amp;req) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if errMsg := validateRequiredFields(map[string]string{
                "pull_request_id": req.PullRequestID,
                "old_user_id":     req.OldUserID,
        }); errMsg != "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, errMsg)
                return
        }</span>

        <span class="cov0" title="0">updatedPR, replacedBy, err := h.store.ReassignReviewer(r.Context(), req.PullRequestID, req.OldUserID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleReassignError(w, err)
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, map[string]interface{}{
                "pr":          updatedPR,
                "replaced_by": replacedBy,
        })</span>
}

func (h *Handler) GetPRsForUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        uid := r.URL.Query().Get("user_id")
        if uid == "" </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "user_id query parameter is required")
                return
        }</span>

        <span class="cov0" title="0">prs, err := h.store.GetPRsForUser(r.Context(), uid)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("GetPRsForUser error: %v", err)
                writeError(w, http.StatusInternalServerError, "internal server error")
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, map[string]interface{}{
                "user_id":       uid,
                "pull_requests": prs,
        })</span>
}

// Вспомогательные функции для обработки ошибок
func (h *Handler) handleStorageError(w http.ResponseWriter, err error, handlerName string) <span class="cov0" title="0">{
        log.Printf("%s error: %v", handlerName, err)

        switch err.Error() </span>{
        case "pr not found", "team not found", "user not found", "author not found",
                "author is not in any team", "old reviewer not in any team":<span class="cov0" title="0">
                writeError(w, http.StatusNotFound, err.Error())</span>
        default:<span class="cov0" title="0">
                writeError(w, http.StatusInternalServerError, err.Error())</span>
        }
}

func (h *Handler) handleCreatePRError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        log.Printf("CreatePR error: %v", err)

        switch err.Error() </span>{
        case "pr already exists":<span class="cov0" title="0">
                writeError(w, http.StatusConflict, "PR id already exists")</span>
        case "author not found", "author is not in any team":<span class="cov0" title="0">
                writeError(w, http.StatusNotFound, err.Error())</span>
        default:<span class="cov0" title="0">
                writeError(w, http.StatusInternalServerError, err.Error())</span>
        }
}

func (h *Handler) handleReassignError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        log.Printf("ReassignReviewer error: %v", err)

        switch err.Error() </span>{
        case "pr not found", "user not found", "user not in any team", "old reviewer not in any team":<span class="cov0" title="0">
                // ДОБАВИТЬ "old reviewer not in any team" в 404 ошибки
                writeError(w, http.StatusNotFound, err.Error())</span>
        case "cannot modify reviewers after merge", "reviewer is not assigned to this PR",
                "no active replacement candidate in team":<span class="cov0" title="0">
                writeError(w, http.StatusConflict, err.Error())</span>
        default:<span class="cov0" title="0">
                writeError(w, http.StatusInternalServerError, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "context"
        "net/http"
        "time"
)

const RequestTimeout = 300 * time.Millisecond

// TimeoutMiddleware добавляет таймаут ко всем HTTP-запросам
func TimeoutMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{

                // Создаём контекст с таймаутом
                ctx, cancel := context.WithTimeout(r.Context(), RequestTimeout)
                defer cancel()

                // Подменяем контекст запроса
                r = r.WithContext(ctx)

                // Канал, который закроется, если запрос завершён
                done := make(chan struct{})

                go func() </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        close(done)
                }</span>()

                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // Таймаут или отмена клиента
                        http.Error(w, "request timed out", http.StatusGatewayTimeout)
                        return</span>
                case &lt;-done:<span class="cov0" title="0">
                        return</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "encoding/json"
        "log"
        "net/http"
)

// writeJSON универсальная функция для JSON ответов
func writeJSON(w http.ResponseWriter, statusCode int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        if data != nil </span><span class="cov0" title="0">{
                if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                        log.Printf("JSON encode error: %v", err)
                }</span>
        }
}

// writeError универсальная функция для ошибок
func writeError(w http.ResponseWriter, statusCode int, message string) <span class="cov0" title="0">{
        writeJSON(w, statusCode, map[string]string{"error": message})
}</span>

// writeSuccess универсальная функция для успешных операций
func writeSuccess(w http.ResponseWriter, statusCode int, message string) <span class="cov0" title="0">{
        writeJSON(w, statusCode, map[string]string{"status": message})
}</span>

// bindJSON универсальная функция для парсинга JSON тела
func (h *Handler) bindJSON(w http.ResponseWriter, r *http.Request, v interface{}) bool <span class="cov0" title="0">{
        if err := json.NewDecoder(r.Body).Decode(v); err != nil </span><span class="cov0" title="0">{
                writeError(w, http.StatusBadRequest, "invalid request body")
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// validateRequiredFields проверяет обязательные поля
func validateRequiredFields(fields map[string]string) string <span class="cov8" title="1">{
        for field, value := range fields </span><span class="cov8" title="1">{
                if value == "" </span><span class="cov8" title="1">{
                        return field + " is required"
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package storage

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "math/rand"
        "time"

        "PR_service/internal/models"
)

type StorageData struct {
        db *sql.DB
}

func NewStorage(db *sql.DB) *StorageData <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())
        return &amp;StorageData{db: db}
}</span>

func ApplyMigrations(db *sql.DB) error <span class="cov0" title="0">{
        ddl := `-- 0001 init
CREATE TABLE IF NOT EXISTS teams (
  team_name TEXT PRIMARY KEY
);

CREATE TABLE IF NOT EXISTS users (
  user_id TEXT PRIMARY KEY,
  username TEXT,
  is_active BOOLEAN NOT NULL DEFAULT true
);

CREATE TABLE IF NOT EXISTS team_members (
  team_name TEXT REFERENCES teams(team_name) ON DELETE CASCADE,
  user_id TEXT REFERENCES users(user_id) ON DELETE CASCADE,
  PRIMARY KEY (team_name,user_id)
);

CREATE TABLE IF NOT EXISTS pull_requests (
  pull_request_id TEXT PRIMARY KEY,
  pull_request_name TEXT,
  author_id TEXT REFERENCES users(user_id),
  status TEXT NOT NULL DEFAULT 'OPEN',
  merged_at TIMESTAMP WITH TIME ZONE NULL
);

CREATE TABLE IF NOT EXISTS pr_reviewers (
  pull_request_id TEXT REFERENCES pull_requests(pull_request_id) ON DELETE CASCADE,
  user_id TEXT REFERENCES users(user_id) ON DELETE CASCADE,
  PRIMARY KEY (pull_request_id,user_id)
);

CREATE INDEX IF NOT EXISTS idx_team_members_team ON team_members(team_name);
CREATE INDEX IF NOT EXISTS idx_users_active ON users(is_active);
`
        _, err := db.Exec(ddl)
        return err
}</span>

// Добавление/обновление команды
func (s *StorageData) UpsertTeam(ctx context.Context, t models.Team) error <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //откат при ошибке
        <span class="cov0" title="0">defer tx.Rollback()

        //Если команда новая - создаем, иначе игнорируем
        if _, err := tx.ExecContext(ctx, `INSERT INTO teams(team_name) VALUES($1) ON CONFLICT (team_name) DO NOTHING`, t.TeamName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Upsert users and members:
        <span class="cov0" title="0">for _, u := range t.Members </span><span class="cov0" title="0">{
                //Создает/обновляет пользователя
                if _, err := tx.ExecContext(ctx, `INSERT INTO users(user_id, username, is_active) VALUES($1,$2,$3) ON CONFLICT (user_id) DO UPDATE SET username=EXCLUDED.username`, u.UserID, u.Username, u.IsActive); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                //Добавляет в команду (если не состоит)
                <span class="cov0" title="0">if _, err := tx.ExecContext(ctx, `INSERT INTO team_members(team_name,user_id) VALUES($1,$2) ON CONFLICT DO NOTHING`, t.TeamName, u.UserID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return tx.Commit()</span>
}

func (s *StorageData) SetUserActive(ctx context.Context, userID string, active bool) error <span class="cov0" title="0">{
        _, err := s.db.ExecContext(ctx, `UPDATE users SET is_active=$1 WHERE user_id=$2`, active, userID)
        return err
}</span>

func (s *StorageData) CreatePR(ctx context.Context, pr models.CreatePRRequest) (*models.PullRequest, error) <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Проверяем существование автора
        var authorExists bool
        err = tx.QueryRowContext(ctx,
                `SELECT EXISTS(SELECT 1 FROM users WHERE user_id = $1)`, pr.AuthorID).Scan(&amp;authorExists)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !authorExists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("author not found")
        }</span>

        // Проверяем что автор состоит хотя бы в одной команде
        <span class="cov0" title="0">var teamName string
        err = tx.QueryRowContext(ctx,
                `SELECT team_name FROM team_members WHERE user_id = $1 LIMIT 1`, pr.AuthorID).Scan(&amp;teamName)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("author is not in any team")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Проверяем существование PR
        <span class="cov0" title="0">var prExists bool
        err = tx.QueryRowContext(ctx,
                `SELECT EXISTS(SELECT 1 FROM pull_requests WHERE pull_request_id = $1)`, pr.PullRequestID).Scan(&amp;prExists)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if prExists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pr already exists")
        }</span>

        // Создаем PR
        <span class="cov0" title="0">if _, err := tx.ExecContext(ctx,
                `INSERT INTO pull_requests(pull_request_id, pull_request_name, author_id, status) VALUES($1,$2,$3,'OPEN')`,
                pr.PullRequestID, pr.PullRequestName, pr.AuthorID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Собираем активных кандидатов исключая автора
        <span class="cov0" title="0">rows, err := tx.QueryContext(ctx,
                `SELECT u.user_id 
                FROM users u 
                JOIN team_members tm ON u.user_id = tm.user_id 
                WHERE tm.team_name = $1 AND u.is_active = true AND u.user_id &lt;&gt; $2`,
                teamName, pr.AuthorID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var candidates []string
        for rows.Next() </span><span class="cov0" title="0">{
                var uid string
                if err := rows.Scan(&amp;uid); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">candidates = append(candidates, uid)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Выбираем до 2 случайных ревьюеров
        <span class="cov0" title="0">selected := pickRandomDistinct(candidates, 2)
        var reviewers []string

        for _, r := range selected </span><span class="cov0" title="0">{
                if _, err := tx.ExecContext(ctx,
                        `INSERT INTO pr_reviewers(pull_request_id, user_id) VALUES($1,$2)`,
                        pr.PullRequestID, r); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">reviewers = append(reviewers, r)</span>
        }

        // Коммитим транзакцию
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Возвращаем созданный PR
        <span class="cov0" title="0">createdPR := &amp;models.PullRequest{
                PullRequestID:   pr.PullRequestID,
                PullRequestName: pr.PullRequestName,
                AuthorID:        pr.AuthorID,
                Status:          "OPEN",
                Reviewers:       reviewers,
        }

        return createdPR, nil</span>
}

// выбрать ревьюера слуайным образом
// мб переписать функцию? очень много операций ради случайности
func pickRandomDistinct(arr []string, n int) []string <span class="cov8" title="1">{
        // Обработка edge cases
        if arr == nil || n &lt;= 0 </span><span class="cov8" title="1">{
                return []string{}
        }</span>

        <span class="cov8" title="1">if len(arr) &lt;= n </span><span class="cov8" title="1">{
                res := make([]string, len(arr))
                copy(res, arr)
                return res
        }</span>

        // Оригинальная логика
        <span class="cov8" title="1">res := make([]string, len(arr))
        copy(res, arr)
        for i := len(res) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                j := rand.Intn(i + 1)
                res[i], res[j] = res[j], res[i]
        }</span>
        <span class="cov8" title="1">return res[:n]</span>
}

func (s *StorageData) MergePR(ctx context.Context, prID string) (*models.PullRequest, error) <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Получаем текущий PR с блокировкой
        var pr models.PullRequest
        err = tx.QueryRowContext(ctx,
                `SELECT pull_request_id, pull_request_name, author_id, status 
                 FROM pull_requests WHERE pull_request_id = $1 FOR UPDATE`,
                prID).Scan(&amp;pr.PullRequestID, &amp;pr.PullRequestName, &amp;pr.AuthorID, &amp;pr.Status)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pr not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Если уже мерджен - возвращаем текущее состояние
        <span class="cov0" title="0">if pr.Status == "MERGED" </span><span class="cov0" title="0">{
                // Получаем ревьюеров для ответа
                reviewers, err := s.getReviewersForPR(ctx, tx, prID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">pr.Reviewers = reviewers
                return &amp;pr, tx.Commit()</span>
        }

        // Обновляем статус на MERGED и устанавливаем время мерджа
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx,
                `UPDATE pull_requests SET status = 'MERGED', merged_at = CURRENT_TIMESTAMP 
                 WHERE pull_request_id = $1`,
                prID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Получаем ревьюеров
        <span class="cov0" title="0">reviewers, err := s.getReviewersForPR(ctx, tx, prID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">pr.Reviewers = reviewers
        pr.Status = "MERGED"

        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;pr, nil</span>
}

// Вспомогательная функция для получения ревьюеров PR
func (s *StorageData) getReviewersForPR(ctx context.Context, tx *sql.Tx, prID string) ([]string, error) <span class="cov0" title="0">{
        rows, err := tx.QueryContext(ctx,
                `SELECT user_id FROM pr_reviewers WHERE pull_request_id = $1`,
                prID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reviewers []string
        for rows.Next() </span><span class="cov0" title="0">{
                var userID string
                if err := rows.Scan(&amp;userID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">reviewers = append(reviewers, userID)</span>
        }
        <span class="cov0" title="0">return reviewers, rows.Err()</span>
}

// Заменяет одного ревьюера на другого случайного активного пользователя из той же команды.
func (s *StorageData) ReassignReviewer(ctx context.Context, prID string, oldReviewerID string) (*models.PullRequest, string, error) <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Получаем информацию о PR с блокировкой
        var pr models.PullRequest
        var authorID string
        err = tx.QueryRowContext(ctx,
                `SELECT pull_request_id, pull_request_name, author_id, status 
                 FROM pull_requests WHERE pull_request_id = $1 FOR UPDATE`,
                prID).Scan(&amp;pr.PullRequestID, &amp;pr.PullRequestName, &amp;authorID, &amp;pr.Status)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("pr not found")
                }</span>
                <span class="cov0" title="0">return nil, "", err</span>
        }

        // Проверяем что PR не мерджен
        <span class="cov0" title="0">if pr.Status == "MERGED" </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("cannot modify reviewers after merge")
        }</span>

        // СНАЧАЛА проверяем существование пользователя
        <span class="cov0" title="0">var userExists bool
        err = tx.QueryRowContext(ctx,
                `SELECT EXISTS(SELECT 1 FROM users WHERE user_id = $1)`,
                oldReviewerID).Scan(&amp;userExists)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">if !userExists </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("old reviewer not in any team") // или "user not found"
        }</span>

        // ПОТОМ проверяем что старый ревьюер действительно назначен на этот PR
        <span class="cov0" title="0">var isAssigned bool
        err = tx.QueryRowContext(ctx,
                `SELECT EXISTS(SELECT 1 FROM pr_reviewers WHERE pull_request_id = $1 AND user_id = $2)`,
                prID, oldReviewerID).Scan(&amp;isAssigned)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">if !isAssigned </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("reviewer is not assigned to this PR")
        }</span>

        // Находим команду старого ревьюера
        <span class="cov0" title="0">var teamName string
        err = tx.QueryRowContext(ctx,
                `SELECT team_name FROM team_members WHERE user_id = $1 LIMIT 1`,
                oldReviewerID).Scan(&amp;teamName)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("old reviewer not in any team")
                }</span>
                <span class="cov0" title="0">return nil, "", err</span>
        }

        // Ищем кандидатов для замены
        <span class="cov0" title="0">rows, err := tx.QueryContext(ctx, `
                SELECT u.user_id 
                FROM users u
                JOIN team_members tm ON u.user_id = tm.user_id
                LEFT JOIN pr_reviewers pr ON u.user_id = pr.user_id AND pr.pull_request_id = $1
                WHERE tm.team_name = $2 
                  AND u.is_active = true 
                  AND u.user_id &lt;&gt; $3
                  AND pr.user_id IS NULL`,
                prID, teamName, authorID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var candidates []string
        for rows.Next() </span><span class="cov0" title="0">{
                var uid string
                if err := rows.Scan(&amp;uid); err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>
                <span class="cov0" title="0">candidates = append(candidates, uid)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        // Удаляем старого ревьюера
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx,
                `DELETE FROM pr_reviewers WHERE pull_request_id = $1 AND user_id = $2`,
                prID, oldReviewerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">var replacedBy string

        // Выбираем нового ревьюера если есть кандидаты
        if len(candidates) &gt; 0 </span><span class="cov0" title="0">{
                selected := pickRandomDistinct(candidates, 1)
                newID := selected[0]

                _, err = tx.ExecContext(ctx,
                        `INSERT INTO pr_reviewers(pull_request_id, user_id) VALUES($1, $2)`,
                        prID, newID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>
                <span class="cov0" title="0">replacedBy = newID</span>
        } else<span class="cov0" title="0"> {
                // Нет доступных кандидатов
                replacedBy = ""
        }</span>

        // Получаем обновленный список ревьюеров
        <span class="cov0" title="0">reviewers, err := s.getReviewersForPR(ctx, tx, prID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">pr.Reviewers = reviewers
        pr.AuthorID = authorID

        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">return &amp;pr, replacedBy, nil</span>
}

// Get PRs where user is reviewer
func (s *StorageData) GetPRsForUser(ctx context.Context, userID string) ([]models.PullRequest, error) <span class="cov0" title="0">{
        rows, err := s.db.QueryContext(ctx, `SELECT pr.pull_request_id, pr.pull_request_name, pr.author_id, pr.status
FROM pull_requests pr
JOIN pr_reviewers r ON pr.pull_request_id = r.pull_request_id
WHERE r.user_id = $1`, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var res []models.PullRequest
        for rows.Next() </span><span class="cov0" title="0">{
                var pr models.PullRequest
                if err := rows.Scan(&amp;pr.PullRequestID, &amp;pr.PullRequestName, &amp;pr.AuthorID, &amp;pr.Status); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // fetch reviewers
                <span class="cov0" title="0">rrows, err := s.db.QueryContext(ctx, `SELECT user_id FROM pr_reviewers WHERE pull_request_id=$1`, pr.PullRequestID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">var revs []string
                for rrows.Next() </span><span class="cov0" title="0">{
                        var uid string
                        if err := rrows.Scan(&amp;uid); err != nil </span><span class="cov0" title="0">{
                                rrows.Close()
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">revs = append(revs, uid)</span>
                }
                <span class="cov0" title="0">rrows.Close()
                pr.Reviewers = revs
                res = append(res, pr)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

// GetTeam возвращает команду с участниками (с транзакцией)
func (s *StorageData) GetTeam(ctx context.Context, teamName string) (*models.Team, error) <span class="cov0" title="0">{
        tx, err := s.db.BeginTx(ctx, &amp;sql.TxOptions{ReadOnly: true})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Проверяем существование команды
        var exists bool
        err = tx.QueryRowContext(ctx,
                "SELECT EXISTS(SELECT 1 FROM teams WHERE team_name = $1)", teamName).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, errors.New("team not found")
        }</span>

        // Получаем участников команды
        <span class="cov0" title="0">rows, err := tx.QueryContext(ctx, `
                SELECT u.user_id, u.username, u.is_active 
                FROM users u
                JOIN team_members tm ON u.user_id = tm.user_id
                WHERE tm.team_name = $1
                ORDER BY u.user_id`, teamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var members []models.User
        for rows.Next() </span><span class="cov0" title="0">{
                var user models.User
                if err := rows.Scan(&amp;user.UserID, &amp;user.Username, &amp;user.IsActive); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">members = append(members, user)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">team := &amp;models.Team{
                TeamName: teamName,
                Members:  members,
        }

        return team, nil</span>
}

func PickForTest(arr []string, n int) []string <span class="cov8" title="1">{
        return pickRandomDistinct(arr, n)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package storage

// TestCase представляет один тестовый случай
type TestCase struct {
        name           string
        testType       string
        input          interface{}
        expectedResult interface{}
        wantError      bool
}

// PickRandomInput входные данные для тестирования pickRandomDistinct
type PickRandomInput struct {
        arr []string
        n   int
}

// testTable возвращает тестовые случаи для логических функций storage
func testTable() []TestCase <span class="cov0" title="0">{
        return []TestCase{
                {
                        name:     "Pick random from array",
                        testType: "PickRandomDistinct",
                        input: PickRandomInput{
                                arr: []string{"a", "b", "c", "d"},
                                n:   2,
                        },
                        wantError: false,
                },
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
